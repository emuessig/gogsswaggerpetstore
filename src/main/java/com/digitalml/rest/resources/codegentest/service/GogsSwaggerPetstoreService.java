package com.digitalml.rest.resources.codegentest.service;
    	
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import java.net.URL;

import org.apache.commons.collections.CollectionUtils;

import java.lang.Object;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.ws.rs.core.SecurityContext;
import java.security.AccessControlException;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.validation.constraints.*;

import org.dozer.DozerBeanMapper;
import org.dozer.Mapper;

// Import any model objects used by the interface

import com.digitalml.rest.resources.codegentest.*;

/**
 * Service: Gogs Swagger Petstore
 * GOGS: This is a sample server Petstore server.  You can find out more about Swagger at
[http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you
can use the api key &#x60;special-key&#x60; to test the authorization filters.
 *
 * This service has been automatically generated by Ignite
 *
 * @author Group1
 * @version 1.0.2
 *
 */

public abstract class GogsSwaggerPetstoreService {

	private static final Logger LOGGER = LoggerFactory.getLogger(GogsSwaggerPetstoreService.class);

	// Required for JSR-303 validation
	static private ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();

	protected static Mapper mapper;

	static {
		URL configFile = GogsSwaggerPetstoreService.class.getResource("GogsSwaggerPetstoreServiceMappings.xml");
		if (configFile != null) {

			List<String> mappingFiles = new ArrayList<String>();
			mappingFiles.add(configFile.toExternalForm());
			mapper = new DozerBeanMapper(mappingFiles);

		} else {
			mapper = new DozerBeanMapper(); // Use default wildcard mappings only
		}
	}

	protected boolean checkPermissions(SecurityContext securityContext) throws AccessControlException {
		return true;
	}

	/**
	Implements method updatePet	*/
	public UpdatePetReturnDTO updatePet(SecurityContext securityContext, UpdatePetInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method updatePet");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access updatePet");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access updatePet");

		UpdatePetReturnDTO returnValue = new UpdatePetReturnDTO();
        UpdatePetCurrentStateDTO currentState = new UpdatePetCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method addPet	*/
	public AddPetReturnDTO addPet(SecurityContext securityContext, AddPetInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method addPet");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access addPet");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access addPet");

		AddPetReturnDTO returnValue = new AddPetReturnDTO();
        AddPetCurrentStateDTO currentState = new AddPetCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method getUserByName	*/
	public GetUserByNameReturnDTO getUserByName(SecurityContext securityContext, GetUserByNameInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method getUserByName");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access getUserByName");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access getUserByName");

		GetUserByNameReturnDTO returnValue = new GetUserByNameReturnDTO();
        GetUserByNameCurrentStateDTO currentState = new GetUserByNameCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method updateUser
	
		This can only be done by the logged in user.
	*/
	public UpdateUserReturnDTO updateUser(SecurityContext securityContext, UpdateUserInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method updateUser");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access updateUser");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access updateUser");

		UpdateUserReturnDTO returnValue = new UpdateUserReturnDTO();
        UpdateUserCurrentStateDTO currentState = new UpdateUserCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method deleteUser
	
		This can only be done by the logged in user.
	*/
	public DeleteUserReturnDTO deleteUser(SecurityContext securityContext, DeleteUserInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method deleteUser");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access deleteUser");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access deleteUser");

		DeleteUserReturnDTO returnValue = new DeleteUserReturnDTO();
        DeleteUserCurrentStateDTO currentState = new DeleteUserCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method findPetsByStatus
	
		Multiple status values can be provided with comma separated strings
	*/
	public FindPetsByStatusReturnDTO findPetsByStatus(SecurityContext securityContext, FindPetsByStatusInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method findPetsByStatus");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access findPetsByStatus");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access findPetsByStatus");

		FindPetsByStatusReturnDTO returnValue = new FindPetsByStatusReturnDTO();
        FindPetsByStatusCurrentStateDTO currentState = new FindPetsByStatusCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method createUsersWithListInput	*/
	public CreateUsersWithListInputReturnDTO createUsersWithListInput(SecurityContext securityContext, CreateUsersWithListInputInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method createUsersWithListInput");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access createUsersWithListInput");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access createUsersWithListInput");

		CreateUsersWithListInputReturnDTO returnValue = new CreateUsersWithListInputReturnDTO();
        CreateUsersWithListInputCurrentStateDTO currentState = new CreateUsersWithListInputCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method uploadFile	*/
	public UploadFileReturnDTO uploadFile(SecurityContext securityContext, UploadFileInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method uploadFile");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access uploadFile");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access uploadFile");

		UploadFileReturnDTO returnValue = new UploadFileReturnDTO();
        UploadFileCurrentStateDTO currentState = new UploadFileCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method getInventory
	
		Returns a map of status codes to quantities
	*/
	public GetInventoryReturnDTO getInventory(SecurityContext securityContext, GetInventoryInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method getInventory");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access getInventory");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access getInventory");

		GetInventoryReturnDTO returnValue = new GetInventoryReturnDTO();
        GetInventoryCurrentStateDTO currentState = new GetInventoryCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method loginUser	*/
	public LoginUserReturnDTO loginUser(SecurityContext securityContext, LoginUserInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method loginUser");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access loginUser");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access loginUser");

		LoginUserReturnDTO returnValue = new LoginUserReturnDTO();
        LoginUserCurrentStateDTO currentState = new LoginUserCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method createUser
	
		This can only be done by the logged in user.
	*/
	public CreateUserReturnDTO createUser(SecurityContext securityContext, CreateUserInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method createUser");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access createUser");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access createUser");

		CreateUserReturnDTO returnValue = new CreateUserReturnDTO();
        CreateUserCurrentStateDTO currentState = new CreateUserCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method createUsersWithArrayInput	*/
	public CreateUsersWithArrayInputReturnDTO createUsersWithArrayInput(SecurityContext securityContext, CreateUsersWithArrayInputInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method createUsersWithArrayInput");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access createUsersWithArrayInput");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access createUsersWithArrayInput");

		CreateUsersWithArrayInputReturnDTO returnValue = new CreateUsersWithArrayInputReturnDTO();
        CreateUsersWithArrayInputCurrentStateDTO currentState = new CreateUsersWithArrayInputCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method findPetsByTags
	
		Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
	*/
	public FindPetsByTagsReturnDTO findPetsByTags(SecurityContext securityContext, FindPetsByTagsInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method findPetsByTags");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access findPetsByTags");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access findPetsByTags");

		FindPetsByTagsReturnDTO returnValue = new FindPetsByTagsReturnDTO();
        FindPetsByTagsCurrentStateDTO currentState = new FindPetsByTagsCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method placeOrder	*/
	public PlaceOrderReturnDTO placeOrder(SecurityContext securityContext, PlaceOrderInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method placeOrder");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access placeOrder");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access placeOrder");

		PlaceOrderReturnDTO returnValue = new PlaceOrderReturnDTO();
        PlaceOrderCurrentStateDTO currentState = new PlaceOrderCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method logoutUser	*/
	public LogoutUserReturnDTO logoutUser(SecurityContext securityContext, LogoutUserInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method logoutUser");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access logoutUser");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access logoutUser");

		LogoutUserReturnDTO returnValue = new LogoutUserReturnDTO();
        LogoutUserCurrentStateDTO currentState = new LogoutUserCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method getPetById
	
		Returns a single pet
	*/
	public GetPetByIdReturnDTO getPetById(SecurityContext securityContext, GetPetByIdInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method getPetById");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access getPetById");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access getPetById");

		GetPetByIdReturnDTO returnValue = new GetPetByIdReturnDTO();
        GetPetByIdCurrentStateDTO currentState = new GetPetByIdCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method updatePetWithForm	*/
	public UpdatePetWithFormReturnDTO updatePetWithForm(SecurityContext securityContext, UpdatePetWithFormInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method updatePetWithForm");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access updatePetWithForm");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access updatePetWithForm");

		UpdatePetWithFormReturnDTO returnValue = new UpdatePetWithFormReturnDTO();
        UpdatePetWithFormCurrentStateDTO currentState = new UpdatePetWithFormCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method deletePet	*/
	public DeletePetReturnDTO deletePet(SecurityContext securityContext, DeletePetInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method deletePet");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access deletePet");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access deletePet");

		DeletePetReturnDTO returnValue = new DeletePetReturnDTO();
        DeletePetCurrentStateDTO currentState = new DeletePetCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method getOrderById
	
		For valid response try integer IDs with value &gt;&#x3D; 1 and &lt;&#x3D; 10. Other values will generated exceptions
	*/
	public GetOrderByIdReturnDTO getOrderById(SecurityContext securityContext, GetOrderByIdInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method getOrderById");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access getOrderById");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access getOrderById");

		GetOrderByIdReturnDTO returnValue = new GetOrderByIdReturnDTO();
        GetOrderByIdCurrentStateDTO currentState = new GetOrderByIdCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method deleteOrder
	
		For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors
	*/
	public DeleteOrderReturnDTO deleteOrder(SecurityContext securityContext, DeleteOrderInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method deleteOrder");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access deleteOrder");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access deleteOrder");

		DeleteOrderReturnDTO returnValue = new DeleteOrderReturnDTO();
        DeleteOrderCurrentStateDTO currentState = new DeleteOrderCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}


    // Supporting Use Case and Process methods

	public abstract UpdatePetCurrentStateDTO updatePetUseCaseStep1(UpdatePetCurrentStateDTO currentState);
	public abstract UpdatePetCurrentStateDTO updatePetUseCaseStep2(UpdatePetCurrentStateDTO currentState);
	public abstract UpdatePetCurrentStateDTO updatePetUseCaseStep3(UpdatePetCurrentStateDTO currentState);


	public abstract AddPetCurrentStateDTO addPetUseCaseStep1(AddPetCurrentStateDTO currentState);


	public abstract GetUserByNameCurrentStateDTO getUserByNameUseCaseStep1(GetUserByNameCurrentStateDTO currentState);
	public abstract GetUserByNameCurrentStateDTO getUserByNameUseCaseStep2(GetUserByNameCurrentStateDTO currentState);
	public abstract GetUserByNameCurrentStateDTO getUserByNameUseCaseStep3(GetUserByNameCurrentStateDTO currentState);


	public abstract UpdateUserCurrentStateDTO updateUserUseCaseStep1(UpdateUserCurrentStateDTO currentState);
	public abstract UpdateUserCurrentStateDTO updateUserUseCaseStep2(UpdateUserCurrentStateDTO currentState);


	public abstract DeleteUserCurrentStateDTO deleteUserUseCaseStep1(DeleteUserCurrentStateDTO currentState);
	public abstract DeleteUserCurrentStateDTO deleteUserUseCaseStep2(DeleteUserCurrentStateDTO currentState);


	public abstract FindPetsByStatusCurrentStateDTO findPetsByStatusUseCaseStep1(FindPetsByStatusCurrentStateDTO currentState);
	public abstract FindPetsByStatusCurrentStateDTO findPetsByStatusUseCaseStep2(FindPetsByStatusCurrentStateDTO currentState);


	public abstract CreateUsersWithListInputCurrentStateDTO createUsersWithListInputUseCaseStep1(CreateUsersWithListInputCurrentStateDTO currentState);


	public abstract UploadFileCurrentStateDTO uploadFileUseCaseStep1(UploadFileCurrentStateDTO currentState);


	public abstract GetInventoryCurrentStateDTO getInventoryUseCaseStep1(GetInventoryCurrentStateDTO currentState);


	public abstract LoginUserCurrentStateDTO loginUserUseCaseStep1(LoginUserCurrentStateDTO currentState);
	public abstract LoginUserCurrentStateDTO loginUserUseCaseStep2(LoginUserCurrentStateDTO currentState);


	public abstract CreateUserCurrentStateDTO createUserUseCaseStep1(CreateUserCurrentStateDTO currentState);


	public abstract CreateUsersWithArrayInputCurrentStateDTO createUsersWithArrayInputUseCaseStep1(CreateUsersWithArrayInputCurrentStateDTO currentState);


	public abstract FindPetsByTagsCurrentStateDTO findPetsByTagsUseCaseStep1(FindPetsByTagsCurrentStateDTO currentState);
	public abstract FindPetsByTagsCurrentStateDTO findPetsByTagsUseCaseStep2(FindPetsByTagsCurrentStateDTO currentState);


	public abstract PlaceOrderCurrentStateDTO placeOrderUseCaseStep1(PlaceOrderCurrentStateDTO currentState);
	public abstract PlaceOrderCurrentStateDTO placeOrderUseCaseStep2(PlaceOrderCurrentStateDTO currentState);


	public abstract LogoutUserCurrentStateDTO logoutUserUseCaseStep1(LogoutUserCurrentStateDTO currentState);


	public abstract GetPetByIdCurrentStateDTO getPetByIdUseCaseStep1(GetPetByIdCurrentStateDTO currentState);
	public abstract GetPetByIdCurrentStateDTO getPetByIdUseCaseStep2(GetPetByIdCurrentStateDTO currentState);
	public abstract GetPetByIdCurrentStateDTO getPetByIdUseCaseStep3(GetPetByIdCurrentStateDTO currentState);


	public abstract UpdatePetWithFormCurrentStateDTO updatePetWithFormUseCaseStep1(UpdatePetWithFormCurrentStateDTO currentState);


	public abstract DeletePetCurrentStateDTO deletePetUseCaseStep1(DeletePetCurrentStateDTO currentState);
	public abstract DeletePetCurrentStateDTO deletePetUseCaseStep2(DeletePetCurrentStateDTO currentState);


	public abstract GetOrderByIdCurrentStateDTO getOrderByIdUseCaseStep1(GetOrderByIdCurrentStateDTO currentState);
	public abstract GetOrderByIdCurrentStateDTO getOrderByIdUseCaseStep2(GetOrderByIdCurrentStateDTO currentState);
	public abstract GetOrderByIdCurrentStateDTO getOrderByIdUseCaseStep3(GetOrderByIdCurrentStateDTO currentState);


	public abstract DeleteOrderCurrentStateDTO deleteOrderUseCaseStep1(DeleteOrderCurrentStateDTO currentState);
	public abstract DeleteOrderCurrentStateDTO deleteOrderUseCaseStep2(DeleteOrderCurrentStateDTO currentState);


// Supporting Exception classes

// Supporting DTO classes


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation updatePet.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class UpdatePetCurrentStateDTO {
		
		private UpdatePetInputParametersDTO inputs;
		private UpdatePetReturnDTO returnObject;
		private UpdatePetReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public UpdatePetCurrentStateDTO() {
			initialiseDTOs();
		}

		public UpdatePetCurrentStateDTO(UpdatePetInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public UpdatePetInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(UpdatePetReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public UpdatePetReturnStatusDTO getErrorState() {
			return errorState;
		}

		public UpdatePetReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new UpdatePetInputParametersDTO();
			returnObject = new UpdatePetReturnDTO();
			errorState = new UpdatePetReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation updatePet
	 */
	public static class UpdatePetReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation updatePet when an exception has been thrown.
	 */
	public static class UpdatePetReturnStatusDTO {

		private String exceptionMessage;

		public UpdatePetReturnStatusDTO() {
		}

		public UpdatePetReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation updatePet in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class UpdatePetInputParametersDTO {


		private com.digitalml.rest.resources.codegentest.Pet body;

		public com.digitalml.rest.resources.codegentest.Pet getBody() {
			return body;
		}

		public void setBody(com.digitalml.rest.resources.codegentest.Pet body) {
			this.body = body;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<UpdatePetInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<UpdatePetInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<UpdatePetInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation addPet.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class AddPetCurrentStateDTO {
		
		private AddPetInputParametersDTO inputs;
		private AddPetReturnDTO returnObject;
		private AddPetReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public AddPetCurrentStateDTO() {
			initialiseDTOs();
		}

		public AddPetCurrentStateDTO(AddPetInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public AddPetInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(AddPetReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public AddPetReturnStatusDTO getErrorState() {
			return errorState;
		}

		public AddPetReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new AddPetInputParametersDTO();
			returnObject = new AddPetReturnDTO();
			errorState = new AddPetReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation addPet
	 */
	public static class AddPetReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation addPet when an exception has been thrown.
	 */
	public static class AddPetReturnStatusDTO {

		private String exceptionMessage;

		public AddPetReturnStatusDTO() {
		}

		public AddPetReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation addPet in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class AddPetInputParametersDTO {


		private com.digitalml.rest.resources.codegentest.Pet body;

		public com.digitalml.rest.resources.codegentest.Pet getBody() {
			return body;
		}

		public void setBody(com.digitalml.rest.resources.codegentest.Pet body) {
			this.body = body;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<AddPetInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<AddPetInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<AddPetInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation getUserByName.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class GetUserByNameCurrentStateDTO {
		
		private GetUserByNameInputParametersDTO inputs;
		private GetUserByNameReturnDTO returnObject;
		private GetUserByNameReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public GetUserByNameCurrentStateDTO() {
			initialiseDTOs();
		}

		public GetUserByNameCurrentStateDTO(GetUserByNameInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public GetUserByNameInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(GetUserByNameReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public GetUserByNameReturnStatusDTO getErrorState() {
			return errorState;
		}

		public GetUserByNameReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new GetUserByNameInputParametersDTO();
			returnObject = new GetUserByNameReturnDTO();
			errorState = new GetUserByNameReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation getUserByName
	 */
	public static class GetUserByNameReturnDTO {
		private com.digitalml.rest.resources.codegentest.User responseWrapper200GetUserByName;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200GetUserByName = new com.digitalml.rest.resources.codegentest.User();
    	}

		public com.digitalml.rest.resources.codegentest.User getResponseWrapper200GetUserByName() {
			return responseWrapper200GetUserByName;
		}

		public void setResponseWrapper200GetUserByName(com.digitalml.rest.resources.codegentest.User responseWrapper200GetUserByName) {
			this.responseWrapper200GetUserByName = responseWrapper200GetUserByName;
		}

	};

	/**
	 * Holds the return value for the operation getUserByName when an exception has been thrown.
	 */
	public static class GetUserByNameReturnStatusDTO {

		private String exceptionMessage;

		public GetUserByNameReturnStatusDTO() {
		}

		public GetUserByNameReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation getUserByName in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class GetUserByNameInputParametersDTO {


		private String username;

		public String getUsername() {
			return username;
		}

		public void setUsername(String username) {
			this.username = username;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<GetUserByNameInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<GetUserByNameInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<GetUserByNameInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation updateUser.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class UpdateUserCurrentStateDTO {
		
		private UpdateUserInputParametersDTO inputs;
		private UpdateUserReturnDTO returnObject;
		private UpdateUserReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public UpdateUserCurrentStateDTO() {
			initialiseDTOs();
		}

		public UpdateUserCurrentStateDTO(UpdateUserInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public UpdateUserInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(UpdateUserReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public UpdateUserReturnStatusDTO getErrorState() {
			return errorState;
		}

		public UpdateUserReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new UpdateUserInputParametersDTO();
			returnObject = new UpdateUserReturnDTO();
			errorState = new UpdateUserReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation updateUser
	 */
	public static class UpdateUserReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation updateUser when an exception has been thrown.
	 */
	public static class UpdateUserReturnStatusDTO {

		private String exceptionMessage;

		public UpdateUserReturnStatusDTO() {
		}

		public UpdateUserReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation updateUser in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class UpdateUserInputParametersDTO {


		private String username;

		private com.digitalml.rest.resources.codegentest.User body;

		public String getUsername() {
			return username;
		}

		public void setUsername(String username) {
			this.username = username;
		}

		public com.digitalml.rest.resources.codegentest.User getBody() {
			return body;
		}

		public void setBody(com.digitalml.rest.resources.codegentest.User body) {
			this.body = body;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<UpdateUserInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<UpdateUserInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<UpdateUserInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation deleteUser.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class DeleteUserCurrentStateDTO {
		
		private DeleteUserInputParametersDTO inputs;
		private DeleteUserReturnDTO returnObject;
		private DeleteUserReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public DeleteUserCurrentStateDTO() {
			initialiseDTOs();
		}

		public DeleteUserCurrentStateDTO(DeleteUserInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public DeleteUserInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(DeleteUserReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public DeleteUserReturnStatusDTO getErrorState() {
			return errorState;
		}

		public DeleteUserReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new DeleteUserInputParametersDTO();
			returnObject = new DeleteUserReturnDTO();
			errorState = new DeleteUserReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation deleteUser
	 */
	public static class DeleteUserReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation deleteUser when an exception has been thrown.
	 */
	public static class DeleteUserReturnStatusDTO {

		private String exceptionMessage;

		public DeleteUserReturnStatusDTO() {
		}

		public DeleteUserReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation deleteUser in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class DeleteUserInputParametersDTO {


		private String username;

		public String getUsername() {
			return username;
		}

		public void setUsername(String username) {
			this.username = username;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<DeleteUserInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<DeleteUserInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<DeleteUserInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation findPetsByStatus.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class FindPetsByStatusCurrentStateDTO {
		
		private FindPetsByStatusInputParametersDTO inputs;
		private FindPetsByStatusReturnDTO returnObject;
		private FindPetsByStatusReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public FindPetsByStatusCurrentStateDTO() {
			initialiseDTOs();
		}

		public FindPetsByStatusCurrentStateDTO(FindPetsByStatusInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public FindPetsByStatusInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(FindPetsByStatusReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public FindPetsByStatusReturnStatusDTO getErrorState() {
			return errorState;
		}

		public FindPetsByStatusReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new FindPetsByStatusInputParametersDTO();
			returnObject = new FindPetsByStatusReturnDTO();
			errorState = new FindPetsByStatusReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation findPetsByStatus
	 */
	public static class FindPetsByStatusReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation findPetsByStatus when an exception has been thrown.
	 */
	public static class FindPetsByStatusReturnStatusDTO {

		private String exceptionMessage;

		public FindPetsByStatusReturnStatusDTO() {
		}

		public FindPetsByStatusReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation findPetsByStatus in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class FindPetsByStatusInputParametersDTO {


		private List<String> status;

		public List<String> getStatus() {
			return status;
		}

		public void setStatus(List<String> status) {
			this.status = status;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<FindPetsByStatusInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<FindPetsByStatusInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<FindPetsByStatusInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation createUsersWithListInput.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class CreateUsersWithListInputCurrentStateDTO {
		
		private CreateUsersWithListInputInputParametersDTO inputs;
		private CreateUsersWithListInputReturnDTO returnObject;
		private CreateUsersWithListInputReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public CreateUsersWithListInputCurrentStateDTO() {
			initialiseDTOs();
		}

		public CreateUsersWithListInputCurrentStateDTO(CreateUsersWithListInputInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public CreateUsersWithListInputInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(CreateUsersWithListInputReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public CreateUsersWithListInputReturnStatusDTO getErrorState() {
			return errorState;
		}

		public CreateUsersWithListInputReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new CreateUsersWithListInputInputParametersDTO();
			returnObject = new CreateUsersWithListInputReturnDTO();
			errorState = new CreateUsersWithListInputReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation createUsersWithListInput
	 */
	public static class CreateUsersWithListInputReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation createUsersWithListInput when an exception has been thrown.
	 */
	public static class CreateUsersWithListInputReturnStatusDTO {

		private String exceptionMessage;

		public CreateUsersWithListInputReturnStatusDTO() {
		}

		public CreateUsersWithListInputReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation createUsersWithListInput in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class CreateUsersWithListInputInputParametersDTO {


		private List<com.digitalml.rest.resources.codegentest.User> body;

		public List<com.digitalml.rest.resources.codegentest.User> getBody() {
			return body;
		}

		public void setBody(List<com.digitalml.rest.resources.codegentest.User> body) {
			this.body = body;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<CreateUsersWithListInputInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<CreateUsersWithListInputInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<CreateUsersWithListInputInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation uploadFile.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class UploadFileCurrentStateDTO {
		
		private UploadFileInputParametersDTO inputs;
		private UploadFileReturnDTO returnObject;
		private UploadFileReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public UploadFileCurrentStateDTO() {
			initialiseDTOs();
		}

		public UploadFileCurrentStateDTO(UploadFileInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public UploadFileInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(UploadFileReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public UploadFileReturnStatusDTO getErrorState() {
			return errorState;
		}

		public UploadFileReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new UploadFileInputParametersDTO();
			returnObject = new UploadFileReturnDTO();
			errorState = new UploadFileReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation uploadFile
	 */
	public static class UploadFileReturnDTO {
		private com.digitalml.rest.resources.codegentest.ApiResponse responseWrapper200UploadFile;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200UploadFile = new com.digitalml.rest.resources.codegentest.ApiResponse();
    	}

		public com.digitalml.rest.resources.codegentest.ApiResponse getResponseWrapper200UploadFile() {
			return responseWrapper200UploadFile;
		}

		public void setResponseWrapper200UploadFile(com.digitalml.rest.resources.codegentest.ApiResponse responseWrapper200UploadFile) {
			this.responseWrapper200UploadFile = responseWrapper200UploadFile;
		}

	};

	/**
	 * Holds the return value for the operation uploadFile when an exception has been thrown.
	 */
	public static class UploadFileReturnStatusDTO {

		private String exceptionMessage;

		public UploadFileReturnStatusDTO() {
		}

		public UploadFileReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation uploadFile in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class UploadFileInputParametersDTO {


		private int petId;

		private String additionalMetadata;

		private String file;

		public int getPetId() {
			return petId;
		}

		public void setPetId(int petId) {
			this.petId = petId;
		}

		public String getAdditionalMetadata() {
			return additionalMetadata;
		}

		public void setAdditionalMetadata(String additionalMetadata) {
			this.additionalMetadata = additionalMetadata;
		}

		public String getFile() {
			return file;
		}

		public void setFile(String file) {
			this.file = file;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<UploadFileInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<UploadFileInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<UploadFileInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation getInventory.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class GetInventoryCurrentStateDTO {
		
		private GetInventoryInputParametersDTO inputs;
		private GetInventoryReturnDTO returnObject;
		private GetInventoryReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public GetInventoryCurrentStateDTO() {
			initialiseDTOs();
		}

		public GetInventoryCurrentStateDTO(GetInventoryInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public GetInventoryInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(GetInventoryReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public GetInventoryReturnStatusDTO getErrorState() {
			return errorState;
		}

		public GetInventoryReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new GetInventoryInputParametersDTO();
			returnObject = new GetInventoryReturnDTO();
			errorState = new GetInventoryReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation getInventory
	 */
	public static class GetInventoryReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation getInventory when an exception has been thrown.
	 */
	public static class GetInventoryReturnStatusDTO {

		private String exceptionMessage;

		public GetInventoryReturnStatusDTO() {
		}

		public GetInventoryReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation getInventory in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class GetInventoryInputParametersDTO {



		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<GetInventoryInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<GetInventoryInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<GetInventoryInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation loginUser.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class LoginUserCurrentStateDTO {
		
		private LoginUserInputParametersDTO inputs;
		private LoginUserReturnDTO returnObject;
		private LoginUserReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public LoginUserCurrentStateDTO() {
			initialiseDTOs();
		}

		public LoginUserCurrentStateDTO(LoginUserInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public LoginUserInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(LoginUserReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public LoginUserReturnStatusDTO getErrorState() {
			return errorState;
		}

		public LoginUserReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new LoginUserInputParametersDTO();
			returnObject = new LoginUserReturnDTO();
			errorState = new LoginUserReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation loginUser
	 */
	public static class LoginUserReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation loginUser when an exception has been thrown.
	 */
	public static class LoginUserReturnStatusDTO {

		private String exceptionMessage;

		public LoginUserReturnStatusDTO() {
		}

		public LoginUserReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation loginUser in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class LoginUserInputParametersDTO {


		private String username;

		private String password;

		public String getUsername() {
			return username;
		}

		public void setUsername(String username) {
			this.username = username;
		}

		public String getPassword() {
			return password;
		}

		public void setPassword(String password) {
			this.password = password;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<LoginUserInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<LoginUserInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<LoginUserInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation createUser.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class CreateUserCurrentStateDTO {
		
		private CreateUserInputParametersDTO inputs;
		private CreateUserReturnDTO returnObject;
		private CreateUserReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public CreateUserCurrentStateDTO() {
			initialiseDTOs();
		}

		public CreateUserCurrentStateDTO(CreateUserInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public CreateUserInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(CreateUserReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public CreateUserReturnStatusDTO getErrorState() {
			return errorState;
		}

		public CreateUserReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new CreateUserInputParametersDTO();
			returnObject = new CreateUserReturnDTO();
			errorState = new CreateUserReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation createUser
	 */
	public static class CreateUserReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation createUser when an exception has been thrown.
	 */
	public static class CreateUserReturnStatusDTO {

		private String exceptionMessage;

		public CreateUserReturnStatusDTO() {
		}

		public CreateUserReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation createUser in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class CreateUserInputParametersDTO {


		private com.digitalml.rest.resources.codegentest.User body;

		public com.digitalml.rest.resources.codegentest.User getBody() {
			return body;
		}

		public void setBody(com.digitalml.rest.resources.codegentest.User body) {
			this.body = body;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<CreateUserInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<CreateUserInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<CreateUserInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation createUsersWithArrayInput.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class CreateUsersWithArrayInputCurrentStateDTO {
		
		private CreateUsersWithArrayInputInputParametersDTO inputs;
		private CreateUsersWithArrayInputReturnDTO returnObject;
		private CreateUsersWithArrayInputReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public CreateUsersWithArrayInputCurrentStateDTO() {
			initialiseDTOs();
		}

		public CreateUsersWithArrayInputCurrentStateDTO(CreateUsersWithArrayInputInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public CreateUsersWithArrayInputInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(CreateUsersWithArrayInputReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public CreateUsersWithArrayInputReturnStatusDTO getErrorState() {
			return errorState;
		}

		public CreateUsersWithArrayInputReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new CreateUsersWithArrayInputInputParametersDTO();
			returnObject = new CreateUsersWithArrayInputReturnDTO();
			errorState = new CreateUsersWithArrayInputReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation createUsersWithArrayInput
	 */
	public static class CreateUsersWithArrayInputReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation createUsersWithArrayInput when an exception has been thrown.
	 */
	public static class CreateUsersWithArrayInputReturnStatusDTO {

		private String exceptionMessage;

		public CreateUsersWithArrayInputReturnStatusDTO() {
		}

		public CreateUsersWithArrayInputReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation createUsersWithArrayInput in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class CreateUsersWithArrayInputInputParametersDTO {


		private List<com.digitalml.rest.resources.codegentest.User> body;

		public List<com.digitalml.rest.resources.codegentest.User> getBody() {
			return body;
		}

		public void setBody(List<com.digitalml.rest.resources.codegentest.User> body) {
			this.body = body;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<CreateUsersWithArrayInputInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<CreateUsersWithArrayInputInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<CreateUsersWithArrayInputInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation findPetsByTags.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class FindPetsByTagsCurrentStateDTO {
		
		private FindPetsByTagsInputParametersDTO inputs;
		private FindPetsByTagsReturnDTO returnObject;
		private FindPetsByTagsReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public FindPetsByTagsCurrentStateDTO() {
			initialiseDTOs();
		}

		public FindPetsByTagsCurrentStateDTO(FindPetsByTagsInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public FindPetsByTagsInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(FindPetsByTagsReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public FindPetsByTagsReturnStatusDTO getErrorState() {
			return errorState;
		}

		public FindPetsByTagsReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new FindPetsByTagsInputParametersDTO();
			returnObject = new FindPetsByTagsReturnDTO();
			errorState = new FindPetsByTagsReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation findPetsByTags
	 */
	public static class FindPetsByTagsReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation findPetsByTags when an exception has been thrown.
	 */
	public static class FindPetsByTagsReturnStatusDTO {

		private String exceptionMessage;

		public FindPetsByTagsReturnStatusDTO() {
		}

		public FindPetsByTagsReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation findPetsByTags in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class FindPetsByTagsInputParametersDTO {


		private List<String> tags;

		public List<String> getTags() {
			return tags;
		}

		public void setTags(List<String> tags) {
			this.tags = tags;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<FindPetsByTagsInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<FindPetsByTagsInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<FindPetsByTagsInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation placeOrder.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class PlaceOrderCurrentStateDTO {
		
		private PlaceOrderInputParametersDTO inputs;
		private PlaceOrderReturnDTO returnObject;
		private PlaceOrderReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public PlaceOrderCurrentStateDTO() {
			initialiseDTOs();
		}

		public PlaceOrderCurrentStateDTO(PlaceOrderInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public PlaceOrderInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(PlaceOrderReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public PlaceOrderReturnStatusDTO getErrorState() {
			return errorState;
		}

		public PlaceOrderReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new PlaceOrderInputParametersDTO();
			returnObject = new PlaceOrderReturnDTO();
			errorState = new PlaceOrderReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation placeOrder
	 */
	public static class PlaceOrderReturnDTO {
		private com.digitalml.rest.resources.codegentest.Order responseWrapper200PlaceOrder;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200PlaceOrder = new com.digitalml.rest.resources.codegentest.Order();
    	}

		public com.digitalml.rest.resources.codegentest.Order getResponseWrapper200PlaceOrder() {
			return responseWrapper200PlaceOrder;
		}

		public void setResponseWrapper200PlaceOrder(com.digitalml.rest.resources.codegentest.Order responseWrapper200PlaceOrder) {
			this.responseWrapper200PlaceOrder = responseWrapper200PlaceOrder;
		}

	};

	/**
	 * Holds the return value for the operation placeOrder when an exception has been thrown.
	 */
	public static class PlaceOrderReturnStatusDTO {

		private String exceptionMessage;

		public PlaceOrderReturnStatusDTO() {
		}

		public PlaceOrderReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation placeOrder in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class PlaceOrderInputParametersDTO {


		private com.digitalml.rest.resources.codegentest.Order body;

		public com.digitalml.rest.resources.codegentest.Order getBody() {
			return body;
		}

		public void setBody(com.digitalml.rest.resources.codegentest.Order body) {
			this.body = body;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<PlaceOrderInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<PlaceOrderInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<PlaceOrderInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation logoutUser.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class LogoutUserCurrentStateDTO {
		
		private LogoutUserInputParametersDTO inputs;
		private LogoutUserReturnDTO returnObject;
		private LogoutUserReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public LogoutUserCurrentStateDTO() {
			initialiseDTOs();
		}

		public LogoutUserCurrentStateDTO(LogoutUserInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public LogoutUserInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(LogoutUserReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public LogoutUserReturnStatusDTO getErrorState() {
			return errorState;
		}

		public LogoutUserReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new LogoutUserInputParametersDTO();
			returnObject = new LogoutUserReturnDTO();
			errorState = new LogoutUserReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation logoutUser
	 */
	public static class LogoutUserReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation logoutUser when an exception has been thrown.
	 */
	public static class LogoutUserReturnStatusDTO {

		private String exceptionMessage;

		public LogoutUserReturnStatusDTO() {
		}

		public LogoutUserReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation logoutUser in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class LogoutUserInputParametersDTO {



		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<LogoutUserInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<LogoutUserInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<LogoutUserInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation getPetById.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class GetPetByIdCurrentStateDTO {
		
		private GetPetByIdInputParametersDTO inputs;
		private GetPetByIdReturnDTO returnObject;
		private GetPetByIdReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public GetPetByIdCurrentStateDTO() {
			initialiseDTOs();
		}

		public GetPetByIdCurrentStateDTO(GetPetByIdInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public GetPetByIdInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(GetPetByIdReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public GetPetByIdReturnStatusDTO getErrorState() {
			return errorState;
		}

		public GetPetByIdReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new GetPetByIdInputParametersDTO();
			returnObject = new GetPetByIdReturnDTO();
			errorState = new GetPetByIdReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation getPetById
	 */
	public static class GetPetByIdReturnDTO {
		private com.digitalml.rest.resources.codegentest.Pet responseWrapper200GetPetById;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200GetPetById = new com.digitalml.rest.resources.codegentest.Pet();
    	}

		public com.digitalml.rest.resources.codegentest.Pet getResponseWrapper200GetPetById() {
			return responseWrapper200GetPetById;
		}

		public void setResponseWrapper200GetPetById(com.digitalml.rest.resources.codegentest.Pet responseWrapper200GetPetById) {
			this.responseWrapper200GetPetById = responseWrapper200GetPetById;
		}

	};

	/**
	 * Holds the return value for the operation getPetById when an exception has been thrown.
	 */
	public static class GetPetByIdReturnStatusDTO {

		private String exceptionMessage;

		public GetPetByIdReturnStatusDTO() {
		}

		public GetPetByIdReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation getPetById in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class GetPetByIdInputParametersDTO {


		private int petId;

		public int getPetId() {
			return petId;
		}

		public void setPetId(int petId) {
			this.petId = petId;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<GetPetByIdInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<GetPetByIdInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<GetPetByIdInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation updatePetWithForm.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class UpdatePetWithFormCurrentStateDTO {
		
		private UpdatePetWithFormInputParametersDTO inputs;
		private UpdatePetWithFormReturnDTO returnObject;
		private UpdatePetWithFormReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public UpdatePetWithFormCurrentStateDTO() {
			initialiseDTOs();
		}

		public UpdatePetWithFormCurrentStateDTO(UpdatePetWithFormInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public UpdatePetWithFormInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(UpdatePetWithFormReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public UpdatePetWithFormReturnStatusDTO getErrorState() {
			return errorState;
		}

		public UpdatePetWithFormReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new UpdatePetWithFormInputParametersDTO();
			returnObject = new UpdatePetWithFormReturnDTO();
			errorState = new UpdatePetWithFormReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation updatePetWithForm
	 */
	public static class UpdatePetWithFormReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation updatePetWithForm when an exception has been thrown.
	 */
	public static class UpdatePetWithFormReturnStatusDTO {

		private String exceptionMessage;

		public UpdatePetWithFormReturnStatusDTO() {
		}

		public UpdatePetWithFormReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation updatePetWithForm in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class UpdatePetWithFormInputParametersDTO {


		private int petId;

		private String name;

		private String status;

		public int getPetId() {
			return petId;
		}

		public void setPetId(int petId) {
			this.petId = petId;
		}

		public String getName() {
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public String getStatus() {
			return status;
		}

		public void setStatus(String status) {
			this.status = status;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<UpdatePetWithFormInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<UpdatePetWithFormInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<UpdatePetWithFormInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation deletePet.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class DeletePetCurrentStateDTO {
		
		private DeletePetInputParametersDTO inputs;
		private DeletePetReturnDTO returnObject;
		private DeletePetReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public DeletePetCurrentStateDTO() {
			initialiseDTOs();
		}

		public DeletePetCurrentStateDTO(DeletePetInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public DeletePetInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(DeletePetReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public DeletePetReturnStatusDTO getErrorState() {
			return errorState;
		}

		public DeletePetReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new DeletePetInputParametersDTO();
			returnObject = new DeletePetReturnDTO();
			errorState = new DeletePetReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation deletePet
	 */
	public static class DeletePetReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation deletePet when an exception has been thrown.
	 */
	public static class DeletePetReturnStatusDTO {

		private String exceptionMessage;

		public DeletePetReturnStatusDTO() {
		}

		public DeletePetReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation deletePet in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class DeletePetInputParametersDTO {


		private int petId;

		public int getPetId() {
			return petId;
		}

		public void setPetId(int petId) {
			this.petId = petId;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<DeletePetInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<DeletePetInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<DeletePetInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation getOrderById.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class GetOrderByIdCurrentStateDTO {
		
		private GetOrderByIdInputParametersDTO inputs;
		private GetOrderByIdReturnDTO returnObject;
		private GetOrderByIdReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public GetOrderByIdCurrentStateDTO() {
			initialiseDTOs();
		}

		public GetOrderByIdCurrentStateDTO(GetOrderByIdInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public GetOrderByIdInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(GetOrderByIdReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public GetOrderByIdReturnStatusDTO getErrorState() {
			return errorState;
		}

		public GetOrderByIdReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new GetOrderByIdInputParametersDTO();
			returnObject = new GetOrderByIdReturnDTO();
			errorState = new GetOrderByIdReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation getOrderById
	 */
	public static class GetOrderByIdReturnDTO {
		private com.digitalml.rest.resources.codegentest.Order responseWrapper200GetOrderById;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200GetOrderById = new com.digitalml.rest.resources.codegentest.Order();
    	}

		public com.digitalml.rest.resources.codegentest.Order getResponseWrapper200GetOrderById() {
			return responseWrapper200GetOrderById;
		}

		public void setResponseWrapper200GetOrderById(com.digitalml.rest.resources.codegentest.Order responseWrapper200GetOrderById) {
			this.responseWrapper200GetOrderById = responseWrapper200GetOrderById;
		}

	};

	/**
	 * Holds the return value for the operation getOrderById when an exception has been thrown.
	 */
	public static class GetOrderByIdReturnStatusDTO {

		private String exceptionMessage;

		public GetOrderByIdReturnStatusDTO() {
		}

		public GetOrderByIdReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation getOrderById in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class GetOrderByIdInputParametersDTO {


		private int orderId;

		public int getOrderId() {
			return orderId;
		}

		public void setOrderId(int orderId) {
			this.orderId = orderId;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<GetOrderByIdInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<GetOrderByIdInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<GetOrderByIdInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation deleteOrder.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class DeleteOrderCurrentStateDTO {
		
		private DeleteOrderInputParametersDTO inputs;
		private DeleteOrderReturnDTO returnObject;
		private DeleteOrderReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public DeleteOrderCurrentStateDTO() {
			initialiseDTOs();
		}

		public DeleteOrderCurrentStateDTO(DeleteOrderInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public DeleteOrderInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(DeleteOrderReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public DeleteOrderReturnStatusDTO getErrorState() {
			return errorState;
		}

		public DeleteOrderReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new DeleteOrderInputParametersDTO();
			returnObject = new DeleteOrderReturnDTO();
			errorState = new DeleteOrderReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation deleteOrder
	 */
	public static class DeleteOrderReturnDTO {
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	}

	};

	/**
	 * Holds the return value for the operation deleteOrder when an exception has been thrown.
	 */
	public static class DeleteOrderReturnStatusDTO {

		private String exceptionMessage;

		public DeleteOrderReturnStatusDTO() {
		}

		public DeleteOrderReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation deleteOrder in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class DeleteOrderInputParametersDTO {


		private int orderId;

		public int getOrderId() {
			return orderId;
		}

		public void setOrderId(int orderId) {
			this.orderId = orderId;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<DeleteOrderInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<DeleteOrderInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<DeleteOrderInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};

}